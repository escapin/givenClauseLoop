PARSER_BEGIN(Parser)package givenClauseLoop;import java.util.*;
public class Parser{	/**	* Conjunctive Normal Form (CNF) Formulae's Parser.	* Based on CNF fragment of TPTP syntax	* http://www.tptp.org	* http://www.cs.miami.edu/~tptp/TPTP/SyntaxBNF.html	*	*@param input CNF formulae	*@param output	*/	public static void parsing(String input, Object output) throws Exception{		try{				new Parser(new java.io.StringReader(input)).FORMULA();		}catch(Throwable e){			// Catching Throwable is ugly but JavaCC throws Error objects!			throw new ParseException("Syntax check failed: " + e.getMessage());		}    }}PARSER_END(Parser)TOKEN: {	<LOWER_ALFA:		["a"-"z"]>		| 	<UPPER_ALFA:		["A"-"Z"]>		|	<SQ_CHAR:			["\40"-"\46"] |  ["\50"-"\133"] | ["\135"-"\176"]>		// Space and visible characters upto ~, except ' and \ 		|	<NUMERIC:			["0"-"9"]>			 		| 	<ZERO_NUMERIC:  	["0"]>		|	<NON_ZERO_NUMERIC:	["1"-"9"]>		|	<SIGN:				"+" | "-">		|	<SINGLE_QUOTE: 		"'">		| 	<DOLLAR:			"$">		|	<VLINE:				"|">		|	<NOT:				"~">		}		SKIP:  { " " | "\t" | "\n" | "\r" }	// "\r" --> backspaceSPECIAL_TOKEN: {		<SINGLE_LINE_COMMENT: "%"(~["\n","\r"])* ("\n"|"\r"|"\r\n")? >		/* The "~" symbol means to complement the regular expression, 		 * the set of characters it represents is any UNICODE character not in the specified set.		 */  		}/*		TOKEN: {  "-" | "(" | ")" | ";" | ","		| <EqNotEq: "=" | "!=" >		| "atom" | "cons" | <CADR: "car" | "cdr">		| <PRED: (["A"-"Z"])+(["0"-"9"])*>		| <FUNVAR: (["A"-"Z"])*(["a"-"z"])+(["a"-"z","A"-"Z"])*(["0"-"9"])*>		//| <FUN: (["A"-"Z"])+(["a"-"z"])+(["0"-"9"])*>		//| <VAR: ((["a"-"z"])+(["0"-"9"])*)>		}*/		/*** All the contents of the file*/void TPTP_file(): {}{	TPTP_input() <EOF>}/**  * Set of CNF annotated formulae */void TPTP_input():{}{	( cnf_annotated() )*}/** * An annotated CNF formula */ void cnf_annotated(): {}{	"cnf" "(" name() "," formula_role() "," cnf_formula() ( "," annotations() )? ")" "."}/*** The CNF name*/void name(): {}	{	atomic_word() | integer()	}/*** The CNF formula role*/void formula_role(): {}	{	lower_word()	}/*** The CNF annotations*/void annotations():	{}	{ ( atomic_word() | upper_word() )* }/******************************************************************  CNF FORMULAE (variables implicitly universally quantified) ******************************************************************/void cnf_formula():	{	}{	disjunction()}void disjunction():	{	}{	literal() ( <VLINE> literal() )?	//	disjunction() <VLINE> literal() | literal()} void literal():	{	  Token t=null;	}{	atomic_formula() | t=<NOT> atomic_formula() }void atomic_formula():	{	}{	atomic_word() | atomic_word() "(" arguments() ")"	//this production represents predicates}/******************************************************************		TERM	***************************************************************************/void arguments():	{	}{	term()  ( "," term() )?	//terms()  | terms() "," arguments()}/******************************************************************		WORD	***************************************************************************/String atomic_word():	{ String s;	}{  	s=lower_word() | s=single_quoted()  	{  	  return s;  	}}String upper_word():	{	Token t1, t2=null;		char c;		StringBuffer s1,s2= new StringBuffer();	}{	// Note: "defined" means a word starting with one $ and "system" means $$	(t1=<DOLLAR> {s1.append(t1.image.charAt(0));} )* t2=<UPPER_ALFA> ( c=alfa_numeric() {s.append(c);} )*	{	  return s1.length()!=0 ? s1.toString() + t2.image + s2.toString() : t2.image + s2.toString();	}}String lower_word():	{	Token t1, t2=null;		char c;		StringBuffer s1,s2= new StringBuffer();	}{  	// Note: "defined" means a word starting with one $ and "system" means $$	(t1=<DOLLAR> {s1.append(t1.image.charAt(0));} )* t2=<LOWER_ALFA> ( c=alfa_numeric() {s.append(c);} )*	{	  return s1.length()!=0 ? s1.toString() + t2.image + s2.toString() : t2.image + s2.toString();	}}/*** A a word in quoted* It can contain also special character apart from ' and \*/String single_quoted():	{	Token t1, t2=null;		StringBuffer s=new StringBuffer();	}{	t1=<SINGLE_QUOTE> ( t2=<SQ_CHAR> {s.append(t2.image.charAt(0));} )+ <SINGLE_QUOTE>	{	  	  return t1.image + s.toString() + t1.image;	}}char alfa_numeric():	{	Token t=null;	}{	t=<LOWER_ALFA> | t=<UPPER_ALFA> | t=<NUMERIC> | t="_" 	{	  return t.image.charAt(0); 	}}/******************************************************************		NUMBER	***************************************************************************/String integer():	{	String s;	}{	s=signed_integer() | s=decimal()	{	  return s;	}}String signed_integer():	{	Token t=null;		String s;	}{	t=<SIGN> s=decimal()	{	  return t.image + s;	}}  String decimal():	{	Token t=null;		String s;	}{	t=<ZERO_NUMERIC> | s=positive_decimal()  {	if(t!=null)    	return t.image;    else    	return s.toString();  }}String positive_decimal():	{	Token t1,t2=null;		StringBuffer s=new StringBuffer();	}{	t1=<NON_ZERO_NUMERIC> ( t2=<NUMERIC> {s.append(t2.image.getChar(0));} )*	{	  return t1.image + s.toString();	}	}/** * Process a clauses void CLAUSE(): 	{	Token token, t=null;	  	Node n1, n2, n3, n4;		String s1, s2, keyNode;		List<Node> arguments;	}{	n1=TERM() token=<EqNotEq> n2=TERM()	{		if(token.image.equals("=")){			ccObj.incrEq();			insertEqual(n1, n2);		}		else{			ccObj.incrNotEq();			insertNotEqual(n1, n2);		}	}	| "atom" "(" n1=TERM() ")"	{		ccObj.incrAtomPos();		ccObj.atomTerm.add(n1.getId());	}	| LOOKAHEAD(2) "-" "atom" "(" n1=TERM() ")"	{		ccObj.incrAtomNeg();		if(!ccObj.notAtomTerm.contains(n1.getId())){			ccObj.notAtomTerm.add(n1.getId());			s1="fv_" + (ccObj.numAtomNeg()*2-1);			s2="fv_" + (ccObj.numAtomNeg()*2);			n3=insertVar(s1);			n4=insertVar(s2);			keyNode=  "cons(" + s1 + "," + s2 + ")";			// in order to keep corrispondence between cons "artificial" node and			// -atom predicates			 			ccObj.addCons(keyNode, "-atom(" + n1.getId() + ")");			n2=ccObj.dag.get(keyNode);			if(n2==null){				n2=new Node(keyNode, "cons");				ccObj.dag.put(keyNode, n2);				ccObj.consTerm.add(keyNode); // in order to maintain "cons" nodes' set				n2.addArg(s1);				n2.addArg(s2);				n3.addParent(keyNode);				n4.addParent(keyNode);				ccObj.incrEdges();				ccObj.incrEdges();			}			// n1, n2			insertEqual(n1, n2);		}	}	| (t="-")? token=<PRED> "(" n1=TERM() {arguments=new LinkedList<Node>(); arguments.add(n1);} 		("," n2=TERM() {arguments.add(n2);} )* ")"	{		// check if a predicate with that name 		// but different arguments' number has been already read		 		Integer p=(Integer) predicates.get(token.image);		if(p!=null){ 			if(p.intValue()!=arguments.size())				throw new ParseException("The predicate \"" + token.image 					+ "\" has been already read with " + p.intValue() + " argument(s)");		}		else			predicates.put(token.image, new Integer(arguments.size()));					s1="";		for(Node n: arguments)			s1+= n.getId() + ","; 		s1=s1.substring(0,s1.length()-1);		keyNode="p_" + token.image + "(" + s1 + ")";		n1=ccObj.dag.get(keyNode);		if(n1==null){			n1=new Node(keyNode, "p_" + token.image);			ccObj.dag.put(keyNode, n1);			for(Node a: arguments){				n1.addArg(a.getId());				a.addParent(keyNode);				ccObj.incrEdges();			}		}			n2=insertVar("#");		// n1 n2 t		if(t==null){			ccObj.incrPredPos();			insertEqual(n1, n2);		}else{			ccObj.incrPredNeg();			insertNotEqual(n1, n2);		}	}}Node TERM(): 	{	Token token;		Node node, n1, n2;		String keyNode, id1, id2;		List<Node> arguments;	}{	token=<CADR> "(" n1=TERM() ")"	 		{		id1=n1.getId();		keyNode= token.image + "(" + id1 + ")";		node=ccObj.dag.get(keyNode);		if(node==null){			node=new Node(keyNode, token.image);		  	ccObj.dag.put(keyNode, node);		  	node.addArg(id1);		  	n1.addParent(keyNode);		  	ccObj.incrEdges();		}		return node;	}	| token="cons" "(" n1=TERM() "," n2=TERM() ")"	{		id1=n1.getId();		id2=n2.getId();		keyNode= token.image + "(" + id1 + "," + id2 + ")";		node=ccObj.dag.get(keyNode);		if(node==null){			node=new Node(keyNode, token.image);			ccObj.dag.put(keyNode, node);			ccObj.consTerm.add(keyNode); // in order to maintain a "cons" nodes' List			node.addArg(id1);			node.addArg(id2);			n1.addParent(keyNode);			n2.addParent(keyNode);			ccObj.incrEdges();			ccObj.incrEdges();		}		return node;	}	| token=<FUNVAR> {arguments=new ArrayList<Node>();} ( "(" n1=TERM() {arguments.add(n1);} 		("," n2=TERM() {arguments.add(n2);} )* ")" )?	{				if(arguments.size()==0) // the token is a variable/costant				return insertVar(token.image);			else{					// the token is an uninterpreted function				// check if a function with that name 				// but different arguments' number has been already read				Integer f=(Integer) functions.get(token.image);				if(f!=null){ 					if(f.intValue()!=arguments.size())						throw new ParseException("The function \"" + token.image 							+ "\" has been already read with " + f.intValue() + " argument(s)");				}				else					functions.put(token.image, new Integer(arguments.size()));								String s="";				for(Node a: arguments)					s+= a.getId() + ","; 				s=s.substring(0,s.length()-1);				keyNode=token.image + "(" + s + ")";				node=(ccObj.dag.get(keyNode));				if(node==null){					node=new Node(keyNode, token.image);					ccObj.dag.put(keyNode, node);					for(Node a: arguments){						node.addArg(a.getId());						a.addParent(keyNode);						ccObj.incrEdges();					}				}				return node;			}	}}*/
