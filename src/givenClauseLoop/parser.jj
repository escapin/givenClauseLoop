PARSER_BEGIN(Parser)package givenClauseLoop;//import java.util.*;
public class Parser{	/**	* Conjunctive Normal Form (CNF) Formulae's Parser.	* Based on CNF fragment of TPTP syntax	* http://www.tptp.org	* http://www.cs.miami.edu/~tptp/TPTP/SyntaxBNF.html	*	*@param input CNF formulae	*@param output	*/	public static void parsing(String input,Object output) throws Exception{		try{				new Parser(new java.io.StringReader(input)).TPTP_file();		}catch(Throwable e){			// Catching Throwable is ugly but JavaCC throws Error objects!			throw new ParseException("Syntax check failed: " + e.getMessage());		}    }}PARSER_END(Parser)SKIP:  { " " | "\t" | "\n" | "\r" }	// "\r" is the backspace escape symbolSPECIAL_TOKEN: {			<SINGLE_LINE_COMMENT:	"%"(~["\n","\r"])*("\n"|"\r"|"\r\n")? >			/* The "~" symbol means to complement the regular expression, 			 * the set of characters it represents is any UNICODE character not in the specified set.			 */  			}TOKEN: {	<VLINE:				"|">		|	<NOT:				"~">		| 	<OPEN_BRACKET:		"(">		| 	<CLOSE_BRACKET:		")">		| 	<DOT:				".">		|	<COMMA:				",">		| 	<CNF:				"cnf"> 		// WORD		| 	<LOWER_WORD:		( <LOWER_ALFA> | <DOLLAR_LOWER_ALFA> ) (<ALFA_NUMERIC>)* >		|	<UPPER_WORD:		( <UPPER_ALFA> | <DOLLAR_UPPER_ALFA> ) (<ALFA_NUMERIC>)* >			//|	<ATOMIC_WORD:		<LOWER_WORD> | <SINGLE_QUOTED> >		|	<SINGLE_QUOTED: 	<SINGLE_QUOTE> (<SQ_CHAR>)+ <SINGLE_QUOTE> >			// symbol: 	(# means 'private regular expression')		|	<#LOWER_ALFA:		["a"-"z"]>		| 	<#UPPER_ALFA:		["A"-"Z"]>		| 	<#DOLLAR_LOWER_ALFA: <DEF_SYS><LOWER_ALFA> >		| 	<#DOLLAR_UPPER_ALFA: <DEF_SYS><UPPER_ALFA> >		|   <#ALFA_NUMERIC:		<LOWER_ALFA> | <UPPER_ALFA> | <NUMERIC> | <UNDERSCORE> >		| 	<#DEF_SYS:			"$" | "$$">		// Note: $ means a "defined" word; $$ means a "system" word		|	<#UNDERSCORE:		"_">		| 	<#SINGLE_QUOTE: 		"'">		|	<#SQ_CHAR:			["\40"-"\46"] |  ["\50"-"\133"] | ["\135"-"\176"]> 	// Space and visible characters upto ~, except ' and \		// NUMBER		|	<INTEGER:			<SIGNED_INTEGER> | <DECIMAL> >		| 	<SIGNED_INTEGER:	<SIGN><DECIMAL> >		|	<DECIMAL:			<ZERO_NUMERIC> | <NON_ZERO_NUMERIC>(<NUMERIC>)*  >    		// symbol: 	(# means 'private regular expression')		|	<#SIGN:				"+" | "-">		|	<#NUMERIC:			["0"-"9"]>			 		| 	<#ZERO_NUMERIC:  	["0"]>		|	<#NON_ZERO_NUMERIC:	["1"-"9"]>		}/*** All the contents of the file*/void TPTP_file(): {}{	TPTP_input() <EOF>}/**  * Set of CNF annotated formulae */void TPTP_input():{}{	( cnf_annotated() )*}/** * An annotated CNF formula */ void cnf_annotated(): {}{	<CNF>  <OPEN_BRACKET> name() <COMMA>  formula_role() <COMMA>  cnf_formula()  ( <COMMA> annotations() )? <CLOSE_BRACKET> <DOT>}/*** The CNF name*/void name(): {}	{ <LOWER_WORD> | <SINGLE_QUOTED> | <INTEGER> }/*** The CNF formula role*/void formula_role(): {}	{	<LOWER_WORD>	}/*** The CNF annotations*/void annotations():	{}	{ ( <LOWER_WORD> | <UPPER_WORD> | <SINGLE_QUOTED> )+ }/******************************************************************  CNF FORMULAE (variables implicitly universally quantified) ******************************************************************/void cnf_formula():	{	}{		<OPEN_BRACKET> literal() ( <VLINE> literal() )* <CLOSE_BRACKET>	| 	literal() ( <VLINE> literal() )*}// void disjunction():{}{	disjunction() <VLINE> literal() | literal()	} void literal():	{	  Token t=null;	}{	(t=<NOT>)? atomic_formula()	{	} }void atomic_formula():	{	}{	(<LOWER_WORD> | <SINGLE_QUOTED>)  ( <OPEN_BRACKET> arguments() <CLOSE_BRACKET> )?	//this production represents predicates with or without arguments	// <ATOMIC_WORD:		<LOWER_WORD> | <SINGLE_QUOTED> >}/******************************************************************		TERM	***************************************************************************/void arguments():	{	}{	term()  ( <COMMA>  term() )*	//terms()  | terms() "," arguments()}void term():	{	}{  	function_term() | <UPPER_WORD>  // upper_word defines VARIABLES}void function_term():	{	}{	(<LOWER_WORD> | <SINGLE_QUOTED>) ( <OPEN_BRACKET>  arguments() <CLOSE_BRACKET>  )?	// <ATOMIC_WORD:		<LOWER_WORD> | <SINGLE_QUOTED> >	// atomic_word without brackets defines CONSTANT	// atomic_word with brackets defines FUNCTION}