PARSER_BEGIN(Parser)package givenClauseLoop;//import java.util.*;
public class Parser{	/**	* Conjunctive Normal Form (CNF) Formulae's Parser.	* Based on CNF fragment of TPTP syntax	* http://www.tptp.org	* http://www.cs.miami.edu/~tptp/TPTP/SyntaxBNF.html	*	*@param input CNF formulae	*@param output	*/	public static void parsing(String input,Object output) throws Exception{		output="ciao";		try{				new Parser(new java.io.StringReader(input)).TPTP_file();		}catch(Throwable e){			// Catching Throwable is ugly but JavaCC throws Error objects!			throw new ParseException("Syntax check failed: " + e.getMessage());		}    }}PARSER_END(Parser)SKIP:  { " " | "\t" | "\n" | "\r" }	// "\r" is the backspace escape symbolSPECIAL_TOKEN: {			<SINGLE_LINE_COMMENT:	"%"(~["\n","\r"])*("\n"|"\r"|"\r\n")? >			/* The "~" symbol means to complement the regular expression, 			 * the set of characters it represents is any UNICODE character not in the specified set.			 */  			}TOKEN: {	<SIGN:				"+" | "-">		|	<SINGLE_QUOTE: 		"'">		|	<VLINE:				"|">		|	<NOT:				"~">		| 	<OPEN_BRACKET:		"(">		| 	<CLOSE_BRACKET:		")">		| 	<DOT:				".">		|	<COMMA:				",">		|	<UNDERSCORE:		"_">		| 	<DEF_SYS:			"$" | "$$">		| 	<CNF:				"cnf"> 		// Note: $ means a "defined" word; $$ means a "system" word		|	<NUMERIC:			["0"-"9"]>			 		| 	<ZERO_NUMERIC:  	["0"]>		|	<NON_ZERO_NUMERIC:	["1"-"9"]>		|	<LOWER_ALFA:		["a"-"z"]>		| 	<UPPER_ALFA:		["A"-"Z"]>		| 	<DOLLAR_LOWER_ALFA: <DEF_SYS><LOWER_ALFA> >		| 	<DOLLAR_UPPER_ALFA: <DEF_SYS><UPPER_ALFA> >		|   <ALFA_NUMERIC:		<LOWER_ALFA> | <UPPER_ALFA> | <NUMERIC> | <UNDERSCORE> > 		//|	<SQ_CHAR:			<LOWER_ALFA > | <UPPER_ALFA> >		|	<SQ_CHAR:			["\40"-"\46"] |  ["\50"-"\133"] | ["\135"-"\176"]>		// Space and visible characters upto ~, except ' and \ 				}/*** All the contents of the file*/void TPTP_file(): {}{	TPTP_input() <EOF>}/**  * Set of CNF annotated formulae */void TPTP_input():{}{	( cnf_annotated() )*}/** * An annotated CNF formula */ void cnf_annotated(): {}{	<CNF>  <OPEN_BRACKET> name() <COMMA>  formula_role() <COMMA>  cnf_formula()  ( <COMMA> annotations() )? <CLOSE_BRACKET> <DOT>}/*** The CNF name*/void name(): {}	{	atomic_word() | integer()	}/*** The CNF formula role*/void formula_role(): {}	{	lower_word()	}/*** The CNF annotations*/void annotations():	{}	{ ( atomic_word() | upper_word() )+ }/******************************************************************  CNF FORMULAE (variables implicitly universally quantified) ******************************************************************/void cnf_formula():	{	}{	 <OPEN_BRACKET> literal() ( <VLINE> literal() )* <CLOSE_BRACKET>}// void disjunction():{}{	disjunction() <VLINE> literal() | literal()	} void literal():	{	  Token t=null;	}{	(t=<NOT>)? atomic_formula()	{	} }void atomic_formula():	{	}{	atomic_word() ( <OPEN_BRACKET> arguments() <CLOSE_BRACKET> )?	//this production represents predicates with or without arguments}/******************************************************************		TERM	***************************************************************************/void arguments():	{	}{	term()  ( "," term() )?	//terms()  | terms() "," arguments()}void term():	{	}{  	function_term() | upper_word() // upper_word defines VARIABLES}void function_term():	{	}{	atomic_word() ( <OPEN_BRACKET>  arguments() <CLOSE_BRACKET>  )?	// atomic_word without brackets defines CONSTANT	// atomic_word with brackets defines FUNCTION}/******************************************************************		WORD	***************************************************************************/String atomic_word():	{ String s;	}{  	s=lower_word() | s=single_quoted()  	{  	  return s;  	}}String upper_word():	{	Token	t1=null,				t2=null;		StringBuffer s1 = new StringBuffer();	}{	// Note: "defined" means a word starting with one $ and "system" means $$	( t1=<DOLLAR_UPPER_ALFA> | t1=<UPPER_ALFA> ) ( t2=<ALFA_NUMERIC>  {s1.append(t2.image.charAt(0));} )*	{	  return  t1.image + s1.toString();	}}String lower_word():	{	Token	t1=null,				t2=null;		StringBuffer s1 = new StringBuffer();	}{	// Note: "defined" means a word starting with one $ and "system" means $$	( t1=<DOLLAR_LOWER_ALFA> | t1=<LOWER_ALFA> ) ( t2=<ALFA_NUMERIC>  {s1.append(t2.image.charAt(0));} )*	{	  return  t1.image + s1.toString();	}}/*** A a word in quoted* It can contain also special character apart from ' and \*/String single_quoted():	{	Token	t1=null,				t2=null;		StringBuffer s=new StringBuffer();	}{	t1=<SINGLE_QUOTE> ( t2=<SQ_CHAR> {s.append(t2.image.charAt(0));} )+ <SINGLE_QUOTE>	{	  	  return t1.image + s.toString() + t1.image;	}}/******************************************************************		NUMBER	***************************************************************************/String integer():	{	String s;	}{	s=signed_integer() | s=decimal()	{	  return s;	}}String signed_integer():	{	Token t=null;		String s;	}{	t=<SIGN> s=decimal()	{	  return t.image + s;	}}  String decimal():	{	Token t=null;		String s;	}{	t=<ZERO_NUMERIC> | s=positive_decimal()  {	return (t!=null)? t.image : s;  }}String positive_decimal():	{	Token	t1=null,				t2=null;		StringBuffer s=new StringBuffer();	}{	t1=<NON_ZERO_NUMERIC> ( t2=<NUMERIC> {s.append(t2.image.charAt(0));} )*	{	  return t1.image + s;	}	}