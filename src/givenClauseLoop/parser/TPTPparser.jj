PARSER_BEGIN(Parser)

package givenClauseLoop.parser;

import java.util.*;
import givenClauseLoop.bean.*;

public class Parser{

	/**
	 * Contains the functions already read with its args number.
	 * This Map avoids the presence of functions with same name
	 * but different number of attributes. 
	 */
	private static Map<String,Integer> functions;

	/**
	 * Contains the predicates already read with its args number.
	 * This Map avoids the presence of predicates with same name
	 * but different number of attributes. 
	 */
	private static Map<String,Integer> predicates;
	
	/**
	 * Queue of all formulae read
	 */
	private static AbstractQueue<CNFformula> formulae;

	/**
	 * Conjunctive Normal Form (CNF) Formulae's Parser.
	 * Based on CNF fragment of TPTP syntax
	 * http://www.tptp.org
	 * http://www.cs.miami.edu/~tptp/TPTP/SyntaxBNF.html
	 *
	 *@param input CNF formulae
	 *@param output
	 */
	public static AbstractQueue<CNFformula> parsing(String input) throws Exception{
		functions = new HashMap<String, Integer>();
		predicates = new HashMap<String, Integer>();
		formulae  = new PriorityQueue<CNFformula>();
		
		try{	
			new Parser(new java.io.StringReader(input)).TPTP_file();
		}catch(Throwable e){
			// Catching Throwable is ugly but JavaCC throws Error objects!
			throw new ParseException("Syntax check failed: " + e.getMessage());
		}
		return formulae;
    }
}
PARSER_END(Parser)

SKIP:  { " " | "\t" | "\n" | "\r" }	// "\r" is the backspace escape symbol
SPECIAL_TOKEN: {
			<SINGLE_LINE_COMMENT:	"%"(~["\n","\r"])*("\n"|"\r"|"\r\n")? >
			/* The "~" symbol means to complement the regular expression, 
			 * the set of characters it represents is any UNICODE character not in the specified set.
			 */  
			}
TOKEN: {	<VLINE:				"|">
		|	<NOT:				"~">
		| 	<OPEN_BRACKET:		"(">
		| 	<CLOSE_BRACKET:		")">
		| 	<DOT:				".">
		|	<COMMA:				",">
		| 	<CNF:				"cnf"> 
		// WORD
		| 	<LOWER_WORD:		( <LOWER_ALFA> | <DOLLAR_LOWER_ALFA> ) (<ALFA_NUMERIC>)* >
		|	<UPPER_WORD:		( <UPPER_ALFA> | <DOLLAR_UPPER_ALFA> ) (<ALFA_NUMERIC>)* >
			//|	<ATOMIC_WORD:		<LOWER_WORD> | <SINGLE_QUOTED> >
		|	<SINGLE_QUOTED: 	<SINGLE_QUOTE> (<SQ_CHAR>)+ <SINGLE_QUOTE> >	
		// symbol: 	(# means 'private regular expression')
		|	<#LOWER_ALFA:		["a"-"z"]>
		| 	<#UPPER_ALFA:		["A"-"Z"]>
		| 	<#DOLLAR_LOWER_ALFA: <DEF_SYS><LOWER_ALFA> >
		| 	<#DOLLAR_UPPER_ALFA: <DEF_SYS><UPPER_ALFA> >
		|   <#ALFA_NUMERIC:		<LOWER_ALFA> | <UPPER_ALFA> | <NUMERIC> | <UNDERSCORE> >
		| 	<#DEF_SYS:			"$" | "$$">		// Note: $ means a "defined" word; $$ means a "system" word
		|	<#UNDERSCORE:		"_">
		| 	<#SINGLE_QUOTE: 		"'">
		|	<#SQ_CHAR:			["\40"-"\46"] |  ["\50"-"\133"] | ["\135"-"\176"]> 	// Space and visible characters upto ~, except ' and \
		// NUMBER
		|	<INTEGER:			<SIGNED_INTEGER> | <DECIMAL> >
		| 	<SIGNED_INTEGER:	<SIGN><DECIMAL> >
		|	<DECIMAL:			<ZERO_NUMERIC> | <NON_ZERO_NUMERIC>(<NUMERIC>)*  >    
		// symbol: 	(# means 'private regular expression')
		|	<#SIGN:				"+" | "-">
		|	<#NUMERIC:			["0"-"9"]>			 
		| 	<#ZERO_NUMERIC:  	["0"]>
		|	<#NON_ZERO_NUMERIC:	["1"-"9"]>
		}
/**
* All the contents of the file
*/
void TPTP_file(): {}
{
	TPTP_input() <EOF>
}

/** 
 * Set of CNF annotated formulae
 */
void TPTP_input():{}
{
	( cnf_annotated() )*
}

/**
 * An annotated CNF formula
 */ 
void cnf_annotated():
	{
	  CNFformula f;
	}
{
	<CNF>  <OPEN_BRACKET> name() <COMMA>  formula_role() <COMMA>  f=cnf_formula()  ( <COMMA> annotations() )? <CLOSE_BRACKET> <DOT>
	{
	  formulae.add(f);	}
}

/**
* The CNF name
*/
void name(): {}	{ <LOWER_WORD> | <SINGLE_QUOTED> | <INTEGER> }

/**
* The CNF formula role
*/
void formula_role(): {}	{	<LOWER_WORD>	}

/**
* The CNF annotations
*/
void annotations():	{}	{ ( <LOWER_WORD> | <UPPER_WORD> | <SINGLE_QUOTED> )+ }


/****************************************************************
**  CNF FORMULAE (variables implicitly universally quantified) **
****************************************************************/

CNFformula cnf_formula():
	{
	  Predicate p=null;
	  //Set<Predicate> atoms=new TreeSet<Predicate>();
	  Set<Predicate> atoms=new HashSet<Predicate>();
	  int symNumber=0, litNumber=0;
	}
{
	(	<OPEN_BRACKET> p=literal() {atoms.add(p); symNumber+=p.getSymNumber(); litNumber++; } ( <VLINE> p=literal() {atoms.add(p); symNumber+=p.getSymNumber(); litNumber++; } )* <CLOSE_BRACKET>
		| 	p=literal() {atoms.add(p); symNumber+=p.getSymNumber(); litNumber++; } ( <VLINE> p=literal() {atoms.add(p); symNumber+=p.getSymNumber(); litNumber++; } )* )
	{
		CNFformula formula=new CNFformula(atoms, symNumber, litNumber);
	  	return formula;	}
}

Predicate literal():
	{
	  Token t1=null, t2;
	  List<Term> args=null;
	}
{
	(t1=<NOT>)? (t2=<LOWER_WORD> | t2=<SINGLE_QUOTED>)  ( <OPEN_BRACKET> args=arguments() <CLOSE_BRACKET> )?
	//this production represents predicates with or without arguments
	// <ATOMIC_WORD:		<LOWER_WORD> | <SINGLE_QUOTED> >
	{
		Predicate p=new Predicate(t2.image, (t1==null)? true: false);
		if(args!=null)		{			/* check if a predicate with that name 
			 * but different arguments' number has been already read
			 */
			Integer pp=(Integer) predicates.get(t2.image);
			if(pp!=null){
			  if(pp.intValue()!=args.size())
					throw new ParseException("The predicate \"" + t2.image 
						+ "\" has been already read with " + pp.intValue() + " argument(s)");
			}
			else
				predicates.put(t2.image, new Integer(args.size()));  

			p.setArgs(args);
		}
		return p;
	}
}

List<Term> arguments():
	{
	  List<Term> args=new LinkedList<Term>();
	  Term t;
	}
{
	t=term() {args.add(t);} ( <COMMA>  t=term() {args.add(t);} )*
	{
	  return args;
	}
}

/***************************************************
***************		TERM	************************
***************************************************/
Term term():
	{
	  Token t1=null;
	  List<Term> args=null;
	}
{
  	t1=<UPPER_WORD>			// upper_word defines VARIABLE
	{
		// VARIABLE
	 	return new Variable(t1.image);	}
  	| (t1=<LOWER_WORD> | t1=<SINGLE_QUOTED>) ( <OPEN_BRACKET> args=arguments() <CLOSE_BRACKET> )?
		// atomic_word with brackets defines FUNCTION
		// atomic_word without brackets defines CONSTANT
	{
	 	if(args==null) // CONSTANT
			return new Constant(t1.image);
		else		// FUNCTION
		{
			/* check if a function with that name 
			 * but different arguments' number has been already read
			 */
			Integer f=(Integer) functions.get(t1.image);
			if(f!=null){
			  if(f.intValue()!=args.size())
					throw new ParseException("The function \"" + t1.image 
						+ "\" has been already read with " + f.intValue() + " argument(s)");
			}
			else
				functions.put(t1.image, new Integer(args.size()));
			
			Function t=new Function(t1.image);
			t.setArgs(args);
			return t;
		}  	
  	}
}